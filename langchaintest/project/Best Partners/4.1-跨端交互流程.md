4.1 跨端交互流程
提交 human_message（13.2）→ Agent 处理 → 前端轮询（13.3）→ 拉取最新（13.4）

说明（基于当前实际实现）：
- 前端端口：5174（通过代理转发到后端 8080）；后端端口：8080；Agent 端口：2024；PostgreSQL：5432。
- FE→BE 接口：
  - 13.2 提交：POST /api/v1/requirements/submit
  - 13.3 轮询：GET /api/v1/requirements/status?thread_id=...&state_version=...
  - 13.4 获取：GET /api/v1/requirements/state?thread_id=...
- BE→AG 接口：
  - 提交：POST /v1/submit（Agent 内部：执行 LangGraph 并写入 Checkpointer 与 state_repo）
  - 轮询：GET /v1/poll?thread_id=...&client_state_version=...
  - 获取：GET /v1/state?thread_id=...
- 线程标识生成：首次若 FE/BE 未提供 thread_id，则由 Agent 在 /v1/submit 内生成并回传；后续各轮沿用该值。
- 状态存储：
  - Agent 优先使用 Redis 作为 Checkpointer（通过 REDIS_URL 或 AGENT_REDIS_URL），否则回退内存；
  - Agent 同步维护内存快照 state_repo（用于 /v1/poll 和 /v1/state）。
- 数据持久化：BE 在 submit 完成后将 Agent 返回的会话、消息、文档、问题/选项、多文件记录写入 PostgreSQL；status/state 不额外落库。
- 文件对象存储：当前代码未实现后端向对象存储的直传与回填，multi_file.file_path 由 FE 或外部上传流程产生并透传给 Agent 与 DB。

```mermaid
sequenceDiagram
  participant FE as 前端
  participant BE as 业务后端 (FastAPI:8080)
  participant AG as Agent (FastAPI:2024)
  participant RS as Redis(Checkpointer)
  participant DB as PostgreSQL
  participant OS as 对象存储

  Note over FE,BE: 端口一致性：FE 5174 → /api 代理到 BE 8080；AG 2024；DB 5432

  FE->>BE: POST /api/v1/requirements/submit\nbody: human_message + file_info(元数据+file_path) + thread_id? + state_version?
  BE->>BE: 注入模型参数(若未显式传入)；按 thread_id 预载上下文(preload_state)（如 DB 有历史）
  BE->>AG: POST /v1/submit\n转发消息/文件(含 preload_state)
  AG->>RS: 按 configurable.thread_id 读取历史状态（存在则合并）
  AG->>AG: 执行 start→input_processor→file_toolscall_agent→requirements_analysis_agent；state_version += 1
  AG->>RS: 写入最新 State（Redis 可用时）
  AG->>AG: 更新内存 state_repo 快照（供 /v1/poll、/v1/state）
  AG-->>BE: 返回 SubmitResponse\nthread_id/state_version/current_status/requirements_document/question_list/messages/multi_files
  BE->>DB: 落库 sessions/messages/questions/suggestion_options/requirements_documents/multi_file
  BE-->>FE: 返回 thread_id/state_version/current_status

  loop FE 轮询 13.3 每 20s
    FE->>BE: GET /api/v1/requirements/status\nparams: thread_id + state_version
    BE->>AG: GET /v1/poll\nparams: thread_id + client_state_version
    AG->>AG: 从 state_repo 读取 current_state_version
    AG-->>BE: 返回 PollResponse\nhas_update = (current > client)
    BE-->>FE: 返回 has_update/current_state_version\n若 current > client 则停止轮询
  end

  FE->>BE: GET /api/v1/requirements/state?thread_id=...
  BE->>AG: GET /v1/state?thread_id=...
  AG->>AG: 从 state_repo 获取完整 State
  AG-->>BE: 返回完整快照
  BE-->>FE: 返回 requirements_document / question_list / messages / current_status / multi_files

  opt 预留：对象存储直传（当前代码未实现）
    BE->>OS: 上传文件对象
    OS-->>BE: 返回 file_path
    BE->>DB: 更新 multi_file.file_path
  end
```

实现锚点（代码参考）：
- BE 路由：<mcfile name="requirements.py" path="backend/app/routers/requirements.py"></mcfile>
- BE→AG 客户端：<mcfile name="agent_client.py" path="backend/app/services/agent_client.py"></mcfile>
- Agent HTTP：<mcfile name="main.py" path="agent/app/main.py"></mcfile>
- 需求分析节点（state_version 递增与问题/文档产出）：<mcfile name="requirements_analysis_agent.py" path="agent/app/graph/requirements_analysis_agent.py"></mcfile>

要点回顾：
- thread_id 缺省由 Agent 在首次 /v1/submit 生成；BE/FE 后续透传。
- question_id/option_id 统一为 UUIDv4；messages 仅保留最近 1 条 user + 1 条 assistant。
- Redis 可用时使用 RedisSaver；否则使用 MemorySaver，并在 Agent 启动日志中明确指示所选 Checkpointer。
- 轮询与状态读取基于 Agent 内存 state_repo，避免频繁触达 Redis/DB，提交完成后由 BE 进行数据库持久化。